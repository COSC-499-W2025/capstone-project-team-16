# Builds Word resumes for projects and contributors

import os
from datetime import datetime

from docx import Document
from docx.shared import Pt
from file_parser import OUTPUT_DIR


# -------------------------------------------------------------------------
# SHARED HELPERS
# -------------------------------------------------------------------------

def _fmt_date(val):
    """Formats a datetime or ISO string into YYYY-MM-DD."""
    if isinstance(val, datetime):
        return val.date().isoformat()
    if isinstance(val, str):
        return val.split("T")[0]
    return ""


def _save_doc(doc, path):
    """Helper to save a docx with retry logic."""
    while True:
        try:
            doc.save(path)
            return path
        except PermissionError:
            print(f"\n[!] Could not save to '{path}' because it is open.")
            print("Please close the file and press Enter to retry, or type 'cancel' to stop.")
            if input("> ").strip().lower() == "cancel":
                return None
        except Exception as e:
            print(f"Error saving document: {e}")
            return None


# -------------------------------------------------------------------------
# 1. GENERAL PROJECT RESUME (Summary of all projects)
# -------------------------------------------------------------------------


def build_project_line(p: dict) -> str:
    """
    Builds a short resume description about a project (General/Team view).
    Used for the full resume summary.
    """
    name = p.get("project", "Unknown")
    langs = p.get("languages", "Unknown")
    skills = p.get("skills", "NA")
    frameworks = p.get("frameworks", "None")
    duration = p.get("duration_days", 0)
    code_files = p.get("code_files", 0)
    test_files = p.get("test_files", 0)
    project_type = p.get("project_type", "software")

    # Main clause
    main = f"Contributed to project '{name}'"
    if project_type and project_type.lower() != "unknown":
        main = f"Contributed to {project_type.lower()} project '{name}'"
    if langs and langs.lower() != "unknown":
        main += f" using {langs}"

    # Details clause
    details = []
    if code_files:
        details.append(f"{code_files} code files")
    if test_files:
        details.append(f"{test_files} test files")

    if duration:
        details.append(f"over {duration} days")
    
    pieces = [main]
    if details:
        pieces.append("comprising " + ", ".join(details))

    if frameworks and frameworks not in ("None", "NA"):
        pieces.append(f"with frameworks such as {frameworks}")

    return "; ".join(pieces) + "."


def generate_resume(
    project_summaries: list[dict],
    chronological_projects: list[dict],
    skills_output: list[dict],
    scan_timestamp: str = None
) -> str:
    """
    Generates the 'Full Project Resume' Word document.
    Returns the path to the generated file.
    """
    # Sort projects by score
    sorted_projects = sorted(
        project_summaries, key=lambda p: p.get("score", 0), reverse=True
    )

    suffix = ""
    if scan_timestamp:
        suffix = "_" + scan_timestamp.replace(":", "-").replace(" ", "_")

    docx_path = os.path.join(OUTPUT_DIR, f"portfolio_resume{suffix}.docx")

    doc = Document()

    # Title
    title = doc.add_heading("Project Portfolio Resume", level=0)
    title.runs[0].font.size = Pt(20)

    # Placeholder Info
    info_p = doc.add_paragraph()
    info_p.add_run("Generated by Skill Scope").italic = True
    doc.add_paragraph()

    # Top Projects
    doc.add_heading("Top Projects", level=1)
    if not sorted_projects:
        doc.add_paragraph("No projects detected.", style="List Bullet")
    else:
        for p in sorted_projects:
            first = _fmt_date(p.get("first_modified"))
            last = _fmt_date(p.get("last_modified"))

            para = doc.add_paragraph(style="List Bullet")
            para.add_run(p["project"]).bold = True
            if first and last:
                para.add_run(f"  ({first} – {last})")
            para.add_run("\n" + build_project_line(p))

    doc.add_paragraph()

    # Timeline
    doc.add_heading("Project Timeline", level=1)
    for p in chronological_projects:
        para = doc.add_paragraph(style="List Bullet")
        para.add_run(p["name"]).bold = True
        para.add_run(f" – {p['first_used']} → {p['last_used']}")
    doc.add_paragraph()

    # Skills
    doc.add_heading("Skills Used Over Time", level=1)
    if skills_output:
        table = doc.add_table(rows=1, cols=3)
        hdr = table.rows[0].cells
        hdr[0].text = "Skill"
        hdr[1].text = "First Used"
        hdr[2].text = "Last Used"
        for row in skills_output:
            cells = table.add_row().cells
            cells[0].text = row["skill"]
            cells[1].text = row["first_used"]
            cells[2].text = row["last_used"]
    else:
        doc.add_paragraph("No skills detected.", style="List Bullet")

    # Footer
    doc.add_paragraph()
    foot = doc.add_paragraph("Generated automatically from code repositories using Skill Scope.")
    foot.runs[0].italic = True
    foot.runs[0].font.size = Pt(8)

    return _save_doc(doc, docx_path)


# -------------------------------------------------------------------------
# 2. INDIVIDUAL CONTRIBUTOR RESUME (Specific Person)
# -------------------------------------------------------------------------


def _build_personal_project_description(project_name, project_context, user_stats):
    """
    Constructs a sentence describing the user's specific contribution to a project.
    """
    # Context from the project as a whole
    langs = project_context.get("languages", "Unknown")
    skills = project_context.get("skills", "NA")
    frameworks = project_context.get("frameworks", "None")
    
    # User specific stats
    u_files = user_stats.get("files_worked", 0)
    u_code = user_stats.get("user_code_files", 0)
    u_test = user_stats.get("user_test_files", 0)
    u_doc = user_stats.get("user_doc_files", 0)
    u_design = user_stats.get("user_design_files", 0)
    
    # Determine the most appropriate action verb based on work distribution
    verb = "Contributed to"
    total_work = u_code + u_test + u_doc + u_design
    
    if total_work > 0:
        if u_code >= u_test and u_code >= u_doc and u_code >= u_design:
            verb = "Developed key components for"
        elif u_test > u_code and u_test > u_doc:
            verb = "Implemented testing suites for"
        elif u_doc > u_code and u_doc > u_test:
            verb = "Authored technical documentation for"
        elif u_design > u_code:
            verb = "Designed assets and UI elements for"

    parts = []
    parts.append(f"{verb} project development")
    
    # Quantifiable Metrics (Suggestion 5)
    pct = user_stats.get("pct", 0.0)
    if pct > 10.0:
        parts.append(f", contributing {pct:.1f}% of the codebase")
        
    duration = project_context.get("duration_days", 0)
    if duration > 14:
        parts.append(f"over a {duration}-day period")
    
    if langs and langs != "Unknown":
        parts.append(f"using {langs}")
    if frameworks and frameworks not in ("None", "NA"):
        parts.append(f"utilizing frameworks such as {frameworks}")
        
    return " ".join(parts) + "."


def generate_contributor_portfolio(
    contributor_name: str,
    profile_data: dict,
    all_projects_map: dict,
    scan_timestamp: str = None,
    sort_mode: str = "impact"
) -> str:
    """
    Generates a specific resume Word doc for a single contributor.
    """
    if not profile_data:
        return None

    safe_name = "".join(c for c in contributor_name if c.isalnum() or c in (' ', '_', '-')).strip()
    suffix = ""
    if scan_timestamp:
        suffix = "_" + scan_timestamp.replace(":", "-").replace(" ", "_")
        
    docx_path = os.path.join(OUTPUT_DIR, f"Resume_{safe_name}{suffix}.docx")
    
    doc = Document()
    
    # Header
    display_name = contributor_name
    if "@" in contributor_name:
        display_name = contributor_name.split("@")[0]
    display_name = display_name.replace(".", " ").replace("_", " ").title()
    
    title = doc.add_heading(display_name, level=0)
    title.runs[0].font.size = Pt(24)
    doc.add_paragraph(f"Generated on {datetime.now().strftime('%B %d, %Y')}")
    
    # Summary
    doc.add_heading("Professional Summary", level=1)
    
    skills = profile_data.get("skills", [])
    projects_ref = profile_data.get("projects", [])
    
    # Determine a professional title based on skills
    role = "Software Contributor"
    dev_keywords = {"Development", "Programming", "Engineering"}
    if any(any(k in s for k in dev_keywords) for s in skills):
        role = "Software Developer"

    summary_text = f"{role} with a track record of contributions across {len(projects_ref)} project(s)."

    if skills:
        # List top 3 skills naturally
        top_skills = skills[:3]
        summary_text += f" Proficient in {', '.join(top_skills)}"
        if len(skills) > 3:
            summary_text += f", along with expertise in {len(skills)-3} other technologies"
        summary_text += "."
        
    doc.add_paragraph(summary_text)
    doc.add_paragraph()

    # Skills
    doc.add_heading("Technical Skills", level=1)
    if skills:
        p = doc.add_paragraph()
        p.add_run("Languages & Technologies: ").bold = True
        p.add_run(", ".join(skills))
    else:
        doc.add_paragraph("No specific skills detected.")
    doc.add_paragraph()

    # Experience
    doc.add_heading("Project Experience", level=1)
    
    # Prepare projects
    user_projects = []
    for p_ref in projects_ref:
        p_name = p_ref.get("name", "Unknown Project")
        
        # Reconstruct stats
        user_stats = {
            "user_code_files": p_ref.get("user_code_files", 0),
            "user_test_files": p_ref.get("user_test_files", 0),
            "user_doc_files": p_ref.get("user_doc_files", 0),
            "user_design_files": p_ref.get("user_design_files", 0),
            "pct": p_ref.get("pct", 0.0),
            "score": p_ref.get("score", 0.0),
            "files_worked": p_ref.get("files_worked", 0),
            "commit_count": p_ref.get("commit_count", 0)
        }

        # Fallback for files_worked
        if user_stats["files_worked"] == 0 and p_ref.get("files_list"):
             user_stats["files_worked"] = len(p_ref.get("files_list"))

        project_context = all_projects_map.get(p_name, {})
        user_projects.append((p_name, user_stats, project_context))

    # Sort by impact
    user_projects.sort(key=lambda x: x[1]["score"], reverse=True)
    # Sort Projects (Suggestion 6)
    if sort_mode == "date":
        # Chronological (Newest First)
        # Ensure we handle both datetime objects and ISO strings safely
        user_projects.sort(
            key=lambda x: str(x[2].get("last_modified", "")), reverse=True
        )
    else:
        # Functional (Impact Score - Best First)
        user_projects.sort(key=lambda x: x[1]["score"], reverse=True)

    if not user_projects:
        doc.add_paragraph("No project contributions found.")
    else:
        for p_name, u_stats, p_context in user_projects:
            # Filter negligible
            if u_stats["pct"] < 0.1 and u_stats["files_worked"] == 0 and u_stats["commit_count"] == 0:
                continue

            # Date
            start = p_context.get("first_modified")
            end = p_context.get("last_modified")
            date_str = ""
            if start and end:
                date_str = f" ({_fmt_date(start)} – {_fmt_date(end)})"

            # Heading
            p_head = doc.add_heading(level=2)
            p_head.add_run(p_name).bold = True
            if date_str:
                p_head.add_run(date_str).font.size = Pt(11)
            
            # Description
            desc = _build_personal_project_description(p_name, p_context, u_stats)
            doc.add_paragraph(desc, style="List Bullet")
            
            # Skills for this project
            pcs = p_context.get("per_contributor_skills", {})
            my_skills = pcs.get(contributor_name, [])
            if my_skills:
                s_p = doc.add_paragraph(style="List Bullet")
                s_p.add_run("Skills: ").bold = True
                s_p.add_run(", ".join(my_skills))
            
            doc.add_paragraph()

    return _save_doc(doc, docx_path)